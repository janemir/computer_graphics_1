# Импортируем библиотеку matplotlib.pyplot для создания и управления графиками (визуализация 3D модели, соответствует лекции о графике и его построении в Python).
import matplotlib.pyplot as plt
# Импортируем библиотеку numpy для работы с массивами и математическими операциями (нужна для матриц преобразований и векторов, соответствует разделу лекции о линейной алгебре и преобразованиях).
import numpy as np

# Определяем класс Creeper, который инкапсулирует логику работы с моделью крипера (объектно-ориентированный подход, соответствует принципам ООП из лекции).
class Creeper:
    # Метод __init__ — конструктор класса, инициализирует начальные данные и параметры объекта (соответствует лекции о создании объектов и их состояниях).
    def __init__(self):
        # Создаем массив front_points с координатами точек фронтальной стороны модели (z=0) в однородных координатах [x, y, z, 1], что соответствует лекции о гомогенных координатах для упрощения преобразований.
        front_points = np.array([
            [-4, 16, 0, 1], [4, 16, 0, 1], [4, 8, 0, 1], [3, 8, 0, 1], [-3, 8, 0, 1], [-4, 8, 0, 1],
            [-3, 7, 0, 1], [-4, 7, 0, 1], [-4, -7, 0, 1], [-7, -7, 0, 1], [-7, -16, 0, 1], [0, -16, 0, 1],
            [7, -16, 0, 1], [7, -7, 0, 1], [4, -7, 0, 1], [0, -7, 0, 1], [4, 7, 0, 1], [3, 7, 0, 1],
            [2, 9, 0, 1], [2, 12, 0, 1], [1, 12, 0, 1], [1, 13, 0, 1], [3, 13, 0, 1], [3, 15, 0, 1],
            [1, 15, 0, 1], [-1, 13, 0, 1], [-1, 15, 0, 1], [-3, 15, 0, 1], [-3, 13, 0, 1], [-1, 12, 0, 1],
            [-2, 12, 0, 1], [-2, 9, 0, 1], [-1, 9, 0, 1], [-1, 10, 0, 1], [1, 10, 0, 1], [1, 9, 0, 1]
        ], dtype=float)

        # Создаем копию первых 18 точек для спины, изменяя z на -8, чтобы создать 3D-объем (соответствует лекции о преобразовании координат для 3D-модели).
        back_points = front_points[0:18].copy()  # Копируем точки 0-17 для спины.
        back_points[:, 2] = -8  # Изменяем z-координату на -8 (глубина модели, соответствует оси Z в 3D-системе).

        # Объединяем фронтальные и задние точки в один массив (вертикальное объединение, соответствует лекции о манипуляциях с массивами в numpy).
        self.original_points = np.vstack((front_points, back_points))

        # Инициализируем коэффициент масштабирования по оси X (начальное значение 1.0, соответствует лекции о линейных преобразованиях).
        self.scale_x = 1.0
        # Инициализируем коэффициент масштабирования по оси Y (начальное значение 1.0, соответствует лекции о линейных преобразованиях).
        self.scale_y = 1.0
        # Инициализируем коэффициент масштабирования по оси Z (начальное значение 1.0, соответствует лекции о линейных преобразованиях).
        self.scale_z = 1.0
        # Инициализируем вектор смещения (начальное значение [0, 0, 0], соответствует лекции о трансляции в гомогенных координатах).
        self.translation = np.array([0.0, 0.0, 0.0])
        # Инициализируем угол поворота вокруг оси X (начальное значение 0.0, соответствует лекции о поворотах в 3D).
        self.rotation_x = 0.0
        # Инициализируем угол поворота вокруг оси Y (начальное значение 0.0, соответствует лекции о поворотах в 3D).
        self.rotation_y = 0.0
        # Инициализируем угол поворота вокруг оси Z (начальное значение 0.0, соответствует лекции о поворотах в 3D).
        self.rotation_z = 0.0
        # Устанавливаем шаг поворота (5.0 градусов, для интерактивного управления, соответствует лекции о дискретных шагах преобразований).
        self.rotation_step = 5.0
        # Устанавливаем шаг перемещения (0.5 единиц, для интерактивного управления, соответствует лекции о трансляции).
        self.move_step = 0.5
        # Устанавливаем шаг масштабирования (0.1, для интерактивного управления, соответствует лекции о масштабировании).
        self.scale_step = 0.1

        # Инициализируем фигуру (графическое окно, None до создания, соответствует лекции о настройке Matplotlib).
        self.fig = None
        # Инициализируем оси 3D (None до создания, соответствует лекции о 3D-графике).
        self.ax = None
        # Инициализируем список линий (пустой, будет заполняться при отрисовке, соответствует лекции о динамическом обновлении графика).
        self.lines = []
        # Инициализируем объект точек (None до отрисовки, соответствует лекции о scatter-графике).
        self.points_plot = None
        # Инициализируем список текстовых меток (пустой, будет заполняться номерами точек, соответствует лекции о аннотациях).
        self.texts = []
        # Инициализируем объект информационного текста (None до создания, соответствует лекции о аннотациях).
        self.info_text = None

        # Устанавливаем фиксированные пределы по оси X (-20 до 20, чтобы уместить модель, соответствует лекции о настройке осей).
        self.fixed_xlim = (-20, 20)
        # Устанавливаем фиксированные пределы по оси Y (-20 до 20, чтобы уместить модель, соответствует лекции о настройке осей).
        self.fixed_ylim = (-20, 20)
        # Устанавливаем фиксированные пределы по оси Z (-20 до 20, чтобы уместить модель, соответствует лекции о настройке осей).
        self.fixed_zlim = (-20, 20)

        # Устанавливаем центр экрана по оси X (0.0, начальное смещение, соответствует лекции о преобразовании в экранные координаты).
        self.screen_center_x = 0.0
        # Устанавливаем центр экрана по оси Y (0.0, начальное смещение, соответствует лекции о преобразовании в экранные координаты).
        self.screen_center_y = 0.0
        # Устанавливаем центр экрана по оси Z (0.0, начальное смещение, соответствует лекции о преобразовании в экранные координаты).
        self.screen_center_z = 0.0
        # Устанавливаем масштаб по оси X (1.0, начальное значение, соответствует лекции о масштабировании в экранных координатах).
        self.screen_scale_x = 1.0
        # Устанавливаем масштаб по оси Y (1.0, начальное значение, соответствует лекции о масштабировании в экранных координаты).
        self.screen_scale_y = 1.0
        # Устанавливаем масштаб по оси Z (1.0, начальное значение, соответствует лекции о масштабировании в экранных координаты).
        self.screen_scale_z = 1.0

    # Метод get_scale_matrix возвращает матрицу масштабирования 4x4 (соответствует лекции о линейных преобразованиях и гомогенных координатах).
    def get_scale_matrix(self, scale_x, scale_y, scale_z):
        # Создаем массив 4x4 с диагональными элементами scale_x, scale_y, scale_z и 1 для гомогенного компонента (математически: S = diag(scale_x, scale_y, scale_z, 1)).
        return np.array([
            [scale_x, 0, 0, 0],  # Первый ряд: масштабирование по X (согласно формуле из лекции).
            [0, scale_y, 0, 0],  # Второй ряд: масштабирование по Y (согласно формуле из лекции).
            [0, 0, scale_z, 0],  # Третий ряд: масштабирование по Z (согласно формуле из лекции).
            [0, 0, 0, 1]         # Четвертый ряд: гомогенный компонент (сохраняет 1, согласно лекции).
        ])

    # Метод get_rotation_x_matrix возвращает матрицу поворота вокруг оси X 4x4 (соответствует лекции о поворотах в 3D-пространстве).
    def get_rotation_x_matrix(self, angle_deg):
        # Преобразуем угол из градусов в радианы для использования в тригонометрических функциях (соответствует математической конвенции).
        angle_rad = np.radians(angle_deg)
        # Создаем матрицу поворота вокруг оси X (формула: Rx(θ) = [[1, 0, 0, 0], [0, cosθ, -sinθ, 0], [0, sinθ, cosθ, 0], [0, 0, 0, 1]]).
        return np.array([
            [1, 0, 0, 0],                              # Первый ряд: x-координата остается неизменной.
            [0, np.cos(angle_rad), -np.sin(angle_rad), 0],  # Второй ряд: вращение y и z (согласно тригонометрии).
            [0, np.sin(angle_rad), np.cos(angle_rad), 0],   # Третий ряд: вращение y и z (согласно тригонометрии).
            [0, 0, 0, 1]                                    # Четвертый ряд: гомогенный компонент.
        ])

    # Метод get_rotation_y_matrix возвращает матрицу поворота вокруг оси Y 4x4 (соответствует лекции о поворотах в 3D-пространстве).
    def get_rotation_y_matrix(self, angle_deg):
        # Преобразуем угол из градусов в радианы для тригонометрических функций.
        angle_rad = np.radians(angle_deg)
        # Создаем матрицу поворота вокруг оси Y (формула: Ry(θ) = [[cosθ, 0, sinθ, 0], [0, 1, 0, 0], [-sinθ, 0, cosθ, 0], [0, 0, 0, 1]]).
        return np.array([
            [np.cos(angle_rad), 0, np.sin(angle_rad), 0],  # Первый ряд: вращение x и z.
            [0, 1, 0, 0],                                  # Второй ряд: y остается неизменной.
            [-np.sin(angle_rad), 0, np.cos(angle_rad), 0], # Третий ряд: вращение x и z.
            [0, 0, 0, 1]                                   # Четвертый ряд: гомогенный компонент.
        ])

    # Метод get_rotation_z_matrix возвращает матрицу поворота вокруг оси Z 4x4 (соответствует лекции о поворотах в 3D-пространстве).
    def get_rotation_z_matrix(self, angle_deg):
        # Преобразуем угол из градусов в радианы для тригонометрических функций.
        angle_rad = np.radians(angle_deg)
        # Создаем матрицу поворота вокруг оси Z (формула: Rz(θ) = [[cosθ, -sinθ, 0, 0], [sinθ, cosθ, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]]).
        return np.array([
            [np.cos(angle_rad), -np.sin(angle_rad), 0, 0],  # Первый ряд: вращение x и y.
            [np.sin(angle_rad), np.cos(angle_rad), 0, 0],   # Второй ряд: вращение x и y.
            [0, 0, 1, 0],                                   # Третий ряд: z остается неизменной.
            [0, 0, 0, 1]                                    # Четвертый ряд: гомогенный компонент.
        ])

    # Метод get_translation_matrix возвращает матрицу трансляции 4x4 (соответствует лекции о трансляции в гомогенных координатах).
    def get_translation_matrix(self, tx, ty, tz):
        # Создаем матрицу трансляции (формула: T = [[1, 0, 0, tx], [0, 1, 0, ty], [0, 0, 1, tz], [0, 0, 0, 1]]).
        return np.array([
            [1, 0, 0, tx],  # Первый ряд: смещение по x.
            [0, 1, 0, ty],  # Второй ряд: смещение по y.
            [0, 0, 1, tz],  # Третий ряд: смещение по z.
            [0, 0, 0, 1]    # Четвертый ряд: гомогенный компонент.
        ])

    # Метод get_reflection_y_matrix возвращает матрицу отражения относительно оси Y 4x4 (соответствует лекции о линейных отражениях).
    def get_reflection_y_matrix(self):
        # Создаем матрицу отражения (формула: Ry = [[-1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]], отражает по оси X).
        return np.array([
            [-1, 0, 0, 0],  # Первый ряд: инверсия x-координаты.
            [0, 1, 0, 0],   # Второй ряд: y остается неизменной.
            [0, 0, 1, 0],   # Третий ряд: z остается неизменной.
            [0, 0, 0, 1]    # Четвертый ряд: гомогенный компонент.
        ])

    # Метод apply_transformations применяет все преобразования к исходным точкам (соответствует лекции о комбинированных преобразованиях).
    def apply_transformations(self):
        # Получаем матрицу масштабирования с текущими коэффициентами (используем метод get_scale_matrix).
        scale_matrix = self.get_scale_matrix(self.scale_x, self.scale_y, self.scale_z)
        # Получаем матрицу поворота вокруг оси X с текущим углом (используем метод get_rotation_x_matrix).
        rotation_x_matrix = self.get_rotation_x_matrix(self.rotation_x)
        # Получаем матрицу поворота вокруг оси Y с текущим углом (используем метод get_rotation_y_matrix).
        rotation_y_matrix = self.get_rotation_y_matrix(self.rotation_y)
        # Получаем матрицу поворота вокруг оси Z с текущим углом (используем метод get_rotation_z_matrix).
        rotation_z_matrix = self.get_rotation_z_matrix(self.rotation_z)
        # Получаем матрицу трансляции с текущим вектором смещения (используем метод get_translation_matrix).
        translation_matrix = self.get_translation_matrix(self.translation[0], self.translation[1], self.translation[2])
        # Получаем матрицу отражения (используем метод get_reflection_y_matrix).
        reflection_y_matrix = self.get_reflection_y_matrix()

        # Комбинируем матрицы в порядке: трансляция @ поворот Z @ поворот Y @ поворот X @ масштаб @ отражение (соответствует лекции о порядке умножения матриц).
        transformation_matrix = translation_matrix @ rotation_z_matrix @ rotation_y_matrix @ rotation_x_matrix @ scale_matrix @ reflection_y_matrix
        # Создаем массив для хранения преобразованных точек с тем же размером, что и original_points.
        transformed_points = np.zeros_like(self.original_points)
        # Проходим по всем точкам и применяем преобразование (матричное умножение, соответствует лекции о применении преобразований).
        for i in range(len(self.original_points)):
            transformed_points[i] = transformation_matrix @ self.original_points[i]
        # Возвращаем массив преобразованных точек.
        return transformed_points

    # Метод world_to_screen преобразует мировые координаты в экранные (соответствует лекции о проецировании).
    def world_to_screen(self, points):
        # Извлекаем только x, y, z из гомогенных координат [x, y, z, 1] (соответствует лекции о отбрасывании гомогенного компонента).
        world_xyz = points[:, :3]
        # Создаем массив для экранных координат с тем же размером, что и world_xyz.
        screen_points = np.zeros_like(world_xyz)
        # Преобразуем x-координату по формуле X = x0 + x * dx (смещение + масштабирование, соответствует лекции).
        screen_points[:, 0] = self.screen_center_x + world_xyz[:, 0] * self.screen_scale_x
        # Преобразуем y-координату по формуле Y = y0 + y * dy (смещение + масштабирование, соответствует лекции).
        screen_points[:, 1] = self.screen_center_y + world_xyz[:, 1] * self.screen_scale_y
        # Преобразуем z-координату по формуле Z = z0 + z * dz (смещение + масштабирование, соответствует лекции).
        screen_points[:, 2] = self.screen_center_z + world_xyz[:, 2] * self.screen_scale_z
        # Возвращаем экранные координаты (без округления для точности, как в лекции).
        return screen_points

    # Метод screen_to_world преобразует экранные координаты обратно в мировые (соответствует лекции о обратном проецировании).
    def screen_to_world(self, screen_points):
        # Создаем массив для мировых координат с тем же размером, что и screen_points.
        world_xyz = np.zeros_like(screen_points)
        # Преобразуем x-координату обратно по формуле x = (X - x0) / dx (обратное масштабирование, соответствует лекции).
        world_xyz[:, 0] = (screen_points[:, 0] - self.screen_center_x) / self.screen_scale_x
        # Преобразуем y-координату обратно по формуле y = (Y - y0) / dy (обратное масштабирование, соответствует лекции).
        world_xyz[:, 1] = (screen_points[:, 1] - self.screen_center_y) / self.screen_scale_y
        # Преобразуем z-координату обратно по формуле z = (Z - z0) / dz (обратное масштабирование, соответствует лекции).
        world_xyz[:, 2] = (screen_points[:, 2] - self.screen_center_z) / self.screen_scale_z
        # Возвращаем мировые координаты (без гомогенного компонента).
        return world_xyz

    # Метод update_plot обновляет график с учетом всех преобразований (соответствует лекции о динамическом обновлении 3D-графиков).
    def update_plot(self):
        # Проверяем, инициализирована ли фигура (если None, выходим, чтобы избежать ошибок, соответствует хорошей практике программирования).
        if self.fig is None:
            return

        # Удаляем все существующие линии, если они есть в осях (очистка для нового рендера, соответствует лекции о динамическом обновлении).
        for line in self.lines:
            if line in self.ax.lines:
                line.remove()
        # Очищаем список линий (подготовка к новому набору, соответствует управлению состоянием).
        self.lines = []

        # Удаляем существующий объект точек, если он существует (очистка для нового рендера).
        if self.points_plot is not None:
            self.points_plot.remove()

        # Удаляем все существующие текстовые метки, если они есть (очистка для нового рендера).
        for text in self.texts:
            if text in self.ax.texts:
                text.remove()
        # Очищаем список текстовых меток (подготовка к новому набору).
        self.texts = []

        # Удаляем существующий информационный текст, если он есть (очистка для нового рендера).
        if self.info_text is not None and self.info_text in self.ax.texts:
            self.info_text.remove()

        # Применяем все преобразования к исходным точкам (вызываем метод apply_transformations).
        world_points = self.apply_transformations()
        # Преобразуем мировые координаты в экранные (вызываем метод world_to_screen).
        screen_points = self.world_to_screen(world_points)

        # Устанавливаем количество точек фронта (36, включая лицо и тело, соответствует структуре модели).
        num_front = 36

        # Определяем матрицу смежности для фронтальной части (описывает, какие точки соединены линиями, соответствует лекции о графах и топологии).
        front_adjacency = {
            0: [1, 5], 1: [0, 2], 2: [1, 3], 3: [2, 17], 4: [3, 5], 5: [0, 4], 
            6: [4, 7, 17], 7: [6, 8], 8: [7, 9, 15], 9: [8, 10], 10: [9, 11], 
            11: [10, 12], 12: [11, 13], 13: [12, 14], 14: [13, 15, 16], 15: [8, 11, 14], 
            16: [14, 17], 17: [3, 16], 18: [19, 35], 19: [18, 20], 20: [19, 21], 
            21: [20, 22, 24, 25], 22: [21, 23], 23: [22, 24], 24: [21, 23], 
            25: [21, 26, 28, 29], 26: [25, 27], 27: [26, 28], 28: [25, 27], 
            29: [25, 30], 30: [29, 31], 31: [30, 32], 32: [31, 33], 33: [32, 34], 
            34: [33, 35], 35: [18, 34]
        }
        # Создаем матрицу смежности для спины, смещая индексы на num_front (соответствует лекции о копировании структуры).
        back_adjacency = {k + num_front: [v + num_front for v in vals if v < 18] for k, vals in front_adjacency.items() if k < 18}
        # Определяем соединения между фронтом и спиной (каждая точка фронта связана с соответствующей точкой спины, соответствует 3D-моделированию).
        connections = {i: [i + num_front] for i in range(18)}

        # Отрисовываем ребра фронтальной части (цикл по матрице смежности).
        for point_idx, connected_points in front_adjacency.items():
            # Извлекаем экранные координаты первой точки (x1, y1, z1).
            x1, y1, z1 = screen_points[point_idx]
            # Проходим по всем связанным точкам.
            for connected_idx in connected_points:
                # Извлекаем экранные координаты второй точки (x2, y2, z2).
                x2, y2, z2 = screen_points[connected_idx]
                # Рисуем линию между точками (метод plot, соответствует лекции о визуализации).
                line, = self.ax.plot([x1, x2], [y1, y2], [z1, z2], color='deeppink', linewidth=2.5)
                # Добавляем линию в список для последующего удаления.
                self.lines.append(line)

        # Отрисовываем ребра спины (аналогично фронту).
        for point_idx, connected_points in back_adjacency.items():
            x1, y1, z1 = screen_points[point_idx]
            for connected_idx in connected_points:
                x2, y2, z2 = screen_points[connected_idx]
                line, = self.ax.plot([x1, x2], [y1, y2], [z1, z2], color='deeppink', linewidth=2.5)
                self.lines.append(line)

        # Отрисовываем соединения между фронтом и спиной.
        for point_idx, connected_points in connections.items():
            x1, y1, z1 = screen_points[point_idx]
            for connected_idx in connected_points:
                x2, y2, z2 = screen_points[connected_idx]
                line, = self.ax.plot([x1, x2], [y1, y2], [z1, z2], color='deeppink', linewidth=2.5)
                self.lines.append(line)

        # Извлекаем координаты x всех точек для scatter-графика.
        x_coords = screen_points[:, 0]
        # Извлекаем координаты y всех точек для scatter-графика.
        y_coords = screen_points[:, 1]
        # Извлекаем координаты z всех точек для scatter-графика.
        z_coords = screen_points[:, 2]
        # Создаем scatter-график точек (соответствует лекции о визуализации точек).
        self.points_plot = self.ax.scatter(x_coords, y_coords, z_coords, color='hotpink', s=6)

        # Формируем строку с информацией о текущих параметрах (для отображения состояния, соответствует лекции о аннотациях).
        info_text_str = (f'Масштаб X: {self.scale_x:.2f}\n'
                         f'Масштаб Y: {self.scale_y:.2f}\n'
                         f'Масштаб Z: {self.scale_z:.2f}\n'
                         f'Поворот X: {self.rotation_x:.1f}°\n'
                         f'Поворот Y: {self.rotation_y:.1f}°\n'
                         f'Поворот Z: {self.rotation_z:.1f}°\n'
                         f'Позиция: ({self.translation[0]:.2f}, {self.translation[1]:.2f}, {self.translation[2]:.2f})')
        # Добавляем текстовую аннотацию с информацией (соответствует лекции о аннотациях).
        self.info_text = self.ax.text2D(0.02, 0.98, info_text_str, transform=self.ax.transAxes, fontsize=10,
                                        verticalalignment='top', bbox=dict(boxstyle='round', facecolor='pink', alpha=0.8))

        # Устанавливаем пределы по оси X (соответствует лекции о настройке осей).
        self.ax.set_xlim(self.fixed_xlim)
        # Устанавливаем пределы по оси Y (соответствует лекции о настройке осей).
        self.ax.set_ylim(self.fixed_ylim)
        # Устанавливаем пределы по оси Z (соответствует лекции о настройке осей).
        self.ax.set_zlim(self.fixed_zlim)
        # Перерисовываем холст для обновления графика (соответствует лекции о динамическом рендеринге).
        self.fig.canvas.draw()

    # Метод on_key_press обрабатывает нажатия клавиш для интерактивного управления (соответствует лекции о событиях и взаимодействии).
    def on_key_press(self, event):
        # Проверяем, нажата ли клавиша '+' или '=', увеличиваем масштаб равномерно.
        if event.key == '=' or event.key == 'add':
            self.scale_x += self.scale_step  # Увеличиваем масштаб по X.
            self.scale_y += self.scale_step  # Увеличиваем масштаб по Y.
            self.scale_z += self.scale_step  # Увеличиваем масштаб по Z.
        # Проверяем, нажата ли клавиша '-' или 'subtract', уменьшаем масштаб равномерно с ограничением.
        elif event.key == '-' or event.key == 'subtract':
            self.scale_x = max(0.1, self.scale_x - self.scale_step)  # Уменьшаем X, минимум 0.1.
            self.scale_y = max(0.1, self.scale_y - self.scale_step)  # Уменьшаем Y, минимум 0.1.
            self.scale_z = max(0.1, self.scale_z - self.scale_step)  # Уменьшаем Z, минимум 0.1.
        # Проверяем, нажата ли '1', увеличиваем масштаб по X.
        elif event.key == '1':
            self.scale_x += self.scale_step
        # Проверяем, нажата ли '2', уменьшаем масштаб по X с ограничением.
        elif event.key == '2':
            self.scale_x = max(0.1, self.scale_x - self.scale_step)
        # Проверяем, нажата ли '3', увеличиваем масштаб по Y.
        elif event.key == '3':
            self.scale_y += self.scale_step
        # Проверяем, нажата ли '4', уменьшаем масштаб по Y с ограничением.
        elif event.key == '4':
            self.scale_y = max(0.1, self.scale_y - self.scale_step)
        # Проверяем, нажата ли '5', увеличиваем масштаб по Z.
        elif event.key == '5':
            self.scale_z += self.scale_step
        # Проверяем, нажата ли '6', уменьшаем масштаб по Z с ограничением.
        elif event.key == '6':
            self.scale_z = max(0.1, self.scale_z - self.scale_step)
        # Проверяем, нажата ли стрелка вверх, перемещаем по Y вверх.
        elif event.key == 'up':
            self.translation[1] += self.move_step
        # Проверяем, нажата ли стрелка вниз, перемещаем по Y вниз.
        elif event.key == 'down':
            self.translation[1] -= self.move_step
        # Проверяем, нажата ли стрелка влево, перемещаем по X влево.
        elif event.key == 'left':
            self.translation[0] -= self.move_step
        # Проверяем, нажата ли стрелка вправо, перемещаем по X вправо.
        elif event.key == 'right':
            self.translation[0] += self.move_step
        # Проверяем, нажата ли 't', перемещаем по Z вверх.
        elif event.key == 't':
            self.translation[2] += self.move_step
        # Проверяем, нажата ли 'e', перемещаем по Z вниз.
        elif event.key == 'e':
            self.translation[2] -= self.move_step
        # Проверяем, нажат ли Ctrl, поворачиваем вокруг Z по часовой стрелке.
        elif event.key == 'control':
            self.rotation_z += self.rotation_step
        # Проверяем, нажат ли Shift, поворачиваем вокруг Z против часовой стрелки.
        elif event.key == 'shift':
            self.rotation_z -= self.rotation_step
        # Проверяем, нажата ли 'a', поворачиваем вокруг X по часовой стрелке.
        elif event.key == 'a':
            self.rotation_x += self.rotation_step
        # Проверяем, нажата ли 'd', поворачиваем вокруг X против часовой стрелки.
        elif event.key == 'd':
            self.rotation_x -= self.rotation_step
        # Проверяем, нажата ли 'w', поворачиваем вокруг Y по часовой стрелке.
        elif event.key == 'w':
            self.rotation_y += self.rotation_step
        # Проверяем, нажата ли 'r', поворачиваем вокруг Y против часовой стрелки.
        elif event.key == 'r':
            self.rotation_y -= self.rotation_step

        # Обновляем график после изменения параметров (вызываем метод update_plot).
        self.update_plot()

    # Метод draw создает и отображает окно с моделью (соответствует лекции о настройке 3D-окна).
    def draw(self):
        # Включаем интерактивный режим Matplotlib (позволяет обновлять график без закрытия, соответствует лекции).
        plt.ion()
        # Создаем фигуру с размером 12x12 дюймов (настраиваем окно, соответствует лекции о настройке графика).
        self.fig = plt.figure(figsize=(12, 12))
        # Создаем 3D-оси в фигуре (используем projection='3d', соответствует лекции о 3D-графике).
        self.ax = self.fig.add_subplot(111, projection='3d')
        # Устанавливаем равный масштаб по осям (для правильного восприятия 3D, соответствует лекции).
        self.ax.set_aspect('equal')
        # Настраиваем отступы фигуры, чтобы максимизировать область отображения (соответствует лекции о настройке).
        self.fig.subplots_adjust(left=0.02, right=0.98, top=0.95, bottom=0.05)
        # Получаем менеджер окна для настройки размера (соответствует лекции о управлении окном).
        fig_manager = plt.get_current_fig_manager()
        # Пытаемся развернуть окно на полный экран (Windows-совместимость, соответствует лекции).
        try:
            fig_manager.window.showMaximized()
        # Альтернатива для других систем (например, Linux), разворачиваем окно.
        except AttributeError:
            fig_manager.window.state('zoomed')

        # Устанавливаем цвет фона фигуры (lightpink для стилизации, соответствует лекции о кастомизации).
        self.fig.patch.set_facecolor('lightpink')
        # Устанавливаем цвет фона осей (lavenderblush для стилизации, соответствует лекции о кастомизации).
        self.ax.set_facecolor('lavenderblush')
        # Проходим по всем границам осей и настраиваем их цвет и толщину (стилизация, соответствует лекции).
        for spine in self.ax.spines.values():
            spine.set_color('deeppink')  # Устанавливаем цвет границ.
            spine.set_linewidth(2)       # Устанавливаем толщину границ.
        # Рисуем горизонтальную ось (y=0, z=0) пунктиром (для ориентации, соответствует лекции).
        self.ax.plot([-20,20], [0,0], [0,0], color='palevioletred', linestyle='--', alpha=0.7)
        # Рисуем вертикальную ось (x=0, z=0) пунктиром (для ориентации, соответствует лекции).
        self.ax.plot([0,0], [-20,20], [0,0], color='palevioletred', linestyle='--', alpha=0.7)
        # Рисуем ось глубины (x=0, y=0) пунктиром (для ориентации, соответствует лекции).
        self.ax.plot([0,0], [0,0], [-20,20], color='palevioletred', linestyle='--', alpha=0.7)
        # Включаем сетку с прозрачностью и цветом (для ориентации, соответствует лекции).
        self.ax.grid(True, alpha=0.3, color='pink')
        # Устанавливаем заголовок графика (стилизация, соответствует лекции).
        self.ax.set_title('Creeper - ЛР №2', fontsize=14, color='mediumvioletred', pad=10)
        # Настраиваем цвет меток осей (стилизация, соответствует лекции).
        self.ax.tick_params(colors='mediumvioletred')
        # Устанавливаем метку для оси X (соответствует лекции о аннотациях).
        self.ax.set_xlabel('X')
        # Устанавливаем метку для оси Y (соответствует лекции о аннотациях).
        self.ax.set_ylabel('Y')
        # Устанавливаем метку для оси Z (соответствует лекции о аннотациях).
        self.ax.set_zlabel('Z')

        # Формируем строку с инструкциями по управлению (для интерактивности, соответствует лекции).
        instructions = ("Инструкция:\n"
                       "+ - равномерное расширение\n"
                       "- - равномерное сжатие\n"
                       "1/2 - масштабирование по X +/-\n"
                       "3/4 - масштабирование по Y +/-\n"
                       "5/6 - масштабирование по Z +/-\n"
                       "Стрелки - перемещение по X/Y\n"
                       "T/E - перемещение по Z +/-\n"
                       "Ctrl - поворот в плоскости (вокруг Z) +\n"
                       "Shift - поворот в плоскости (вокруг Z) -\n"
                       "A/D - поворот по оси X +/-\n"
                       "W/R - поворот по оси Y +/-")
        # Добавляем инструкции в правый нижний угол (аннотация, соответствует лекции).
        self.ax.text2D(0.98, 0.02, instructions, transform=self.ax.transAxes, fontsize=9,
                     verticalalignment='bottom', horizontalalignment='right',
                     bbox=dict(boxstyle='round', facecolor='lightpink', alpha=0.8))

        # Устанавливаем пределы по оси X (соответствует лекции о настройке осей).
        self.ax.set_xlim(self.fixed_xlim)
        # Устанавливаем пределы по оси Y (соответствует лекции о настройке осей).
        self.ax.set_ylim(self.fixed_ylim)
        # Устанавливаем пределы по оси Z (соответствует лекции о настройке осей).
        self.ax.set_zlim(self.fixed_zlim)

        # Вызываем метод обновления графика (инициализация, соответствует лекции).
        self.update_plot()
        # Подключаем обработчик событий клавиш (соответствует лекции о взаимодействии).
        self.fig.canvas.mpl_connect('key_press_event', self.on_key_press)
        # Отображаем окно и ждем его закрытия (соответствует лекции о рендеринге).
        plt.show(block=True)

# Проверяем, запущен ли скрипт напрямую (не импортирован как модуль, соответствует хорошей практике модульности).
if __name__ == "__main__":
    # Создаем экземпляр класса Creeper для запуска программы.
    creeper = Creeper()
    # Вызываем метод draw для отображения модели (запуск визуализации).
    creeper.draw()